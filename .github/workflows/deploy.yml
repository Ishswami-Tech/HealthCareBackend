name: Deploy Healthcare Backend

on:
  push:
    branches: [main]
  pull_request:
    branches: [main]

permissions:
  contents: read
  packages: write
  actions: read
  deployments: write

env:
  DOCKER_COMPOSE_VERSION: v2.20.2
  WORKER_COUNT: 2
  SERVER_HOST: api.ishswami.in
  SERVER_USER: ${{ secrets.SERVER_USER }}
  SERVER_SSH_KEY: ${{ secrets.SSH_PRIVATE_KEY }}
  DEPLOY_PATH: /var/www/healthcare/backend
  SERVER_IP: 82.208.20.16
  DOMAIN: api.ishswami.in
  FRONTEND_DOMAIN: ishswami.in
  SSL_EMAIL: aadeshbhujbal99@gmail.com
  NODE_ENV: production
  API_URL: https://api.ishswami.in
  API_CONTAINER: latest-api
  POSTGRES_CONTAINER: latest-postgres
  REDIS_CONTAINER: latest-redis
  NETWORK_NAME: app-network
  GOOGLE_CLIENT_ID: ${{ secrets.GOOGLE_CLIENT_ID }}
  GOOGLE_CLIENT_SECRET: ${{ secrets.GOOGLE_CLIENT_SECRET }}
  DEV_MODE: true

jobs:
  pre-deployment-check:
    runs-on: ubuntu-latest
    steps:
      - name: Test SSH connection
        run: |
          echo "Testing SSH connection to ${{ env.SERVER_IP }}..."
          # Create SSH key file
          mkdir -p ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > ~/.ssh/id_rsa
          chmod 600 ~/.ssh/id_rsa

          # Add server to known hosts and test connection with timeout and retries
          ssh-keyscan -H ${{ env.SERVER_IP }} >> ~/.ssh/known_hosts
          # Try multiple times with increasing backoff
          MAX_RETRIES=5
          RETRY_COUNT=0
          CONNECTED=false

          while [ $RETRY_COUNT -lt $MAX_RETRIES ] && [ "$CONNECTED" != "true" ]; do
            RETRY_COUNT=$((RETRY_COUNT + 1))
            SLEEP_TIME=$((RETRY_COUNT * 5))
            
            echo "Connection attempt $RETRY_COUNT/$MAX_RETRIES..."
            if timeout 30s ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=30 -o ServerAliveInterval=10 -o TCPKeepAlive=yes ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} "echo SSH connection successful"; then
            echo "✅ SSH connection successful"
              CONNECTED=true
              break
          else
            echo "❌ SSH connection failed"
              echo "Waiting $SLEEP_TIME seconds before retry..."
              sleep $SLEEP_TIME
            fi
          done

          if [ "$CONNECTED" != "true" ]; then
            echo "All connection attempts failed. Trying one last time with different settings..."
            if timeout 60s ssh -v -o StrictHostKeyChecking=no -o ConnectTimeout=60 -o ServerAliveInterval=15 -o TCPKeepAlive=yes -o IPQoS=throughput ${{ env.SERVER_USER }}@${{ env.SERVER_IP }} "echo SSH connection successful"; then
              echo "✅ Last attempt SSH connection successful"
              CONNECTED=true
            else
              echo "❌ All SSH connection attempts failed"
            echo "Attempting to ping server..."
            ping -c 4 ${{ env.SERVER_IP }}
            exit 1
            fi
          fi

      - name: Check domain DNS
        run: |
          echo "Checking DNS for ${{ env.DOMAIN }}..."
          if ! nslookup ${{ env.DOMAIN }} > /dev/null 2>&1; then
            echo "Warning: Domain ${{ env.DOMAIN }} DNS resolution failed"
            echo "Please ensure domain is properly configured"
            # Don't exit with error as this is just a warning
            echo "Continuing deployment despite DNS warning..."
          else
            echo "Domain ${{ env.DOMAIN }} resolves correctly"
          fi

      - name: Check server connectivity
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          debug: true
          timeout: 120s
          command_timeout: "30m"
          proxy_timeout: 120s
          script: |
            echo "Testing connection to server..."
            echo "Current date and time: $(date)"
            echo "Server IP: $(hostname -I || echo 'hostname command not available')"
            echo "Checking system resources..."
            df -h
            free -m

            # Don't exit if Docker system df fails (first deployment)
            echo "Checking Docker status..."
            docker system df || echo "Docker may not be initialized yet, continuing..."

            echo "Checking required ports..."
            # Use netstat if available, otherwise skip
            if command -v netstat &> /dev/null; then
              for port in 8088 5432 6379 8082; do
                if netstat -tuln | grep -q ":$port "; then
                  echo "Warning: Port $port is already in use"
                  netstat -tuln | grep ":$port "
                else
                  echo "Port $port is available"
                fi
              done
            else
              echo "netstat not available, skipping port check"
            fi

            echo "Checking disk space..."
            DISK_USAGE=$(df -h / | awk 'NR==2 {print $5}' | sed 's/%//')
            if [ "$DISK_USAGE" -gt 85 ]; then
              echo "Warning: Disk usage is above 85%"
              df -h /
            else
              echo "Disk space is sufficient"
            fi

  create-deployment:
    needs: [pre-deployment-check]
    runs-on: ubuntu-latest
    outputs:
      deployment_id: ${{ github.run_id }}
    steps:
      - name: Create deployment marker
        run: echo "Creating deployment with ID ${{ github.run_id }}"

  deploy:
    needs: create-deployment
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
        with:
          fetch-depth: 0

      - name: Create backup and cleanup
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          debug: true
          timeout: 120s
          command_timeout: "30m"
          proxy_timeout: 120s
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            # Create backup directory with timestamp
            timestamp=$(date +%Y%m%d_%H%M%S)
            mkdir -p backups/$timestamp

            # Check if successful deployments file exists
            SUCCESSFUL_DEPLOYMENTS_FILE="${{ env.DEPLOY_PATH }}/successful_deployments.txt"
            CURRENT_DEPLOYMENT_IS_SUCCESSFUL=false

            # Only backup and stop API container since we're only updating the API
            if [ -d "current" ] && [ -f "current/docker-compose.prod.yml" ]; then
              echo "Checking if current deployment is marked as successful..."
              
              # Get current deployment hash
              CURRENT_DEPLOY=$(basename $(readlink -f current))
              echo "Current deployment: $CURRENT_DEPLOY"
              
              # Check if it's in the successful deployments file
              if [ -f "$SUCCESSFUL_DEPLOYMENTS_FILE" ] && grep -q "$CURRENT_DEPLOY" "$SUCCESSFUL_DEPLOYMENTS_FILE"; then
                echo "Current deployment is marked as successful, creating backup..."
                CURRENT_DEPLOYMENT_IS_SUCCESSFUL=true
                
                # Only backup successful deployments
                echo "Creating backup of successful API deployment..."
                cp -r current/* backups/$timestamp/ 2>/dev/null || true
                echo $timestamp > backups/latest_backup
                echo "Backup created with timestamp: $timestamp"
              else
                echo "Current deployment is not marked as successful, skipping backup..."
              fi
              
              echo "Stopping current API deployment..."
              cd current
              
              # Check if API container exists and stop only it
              if docker ps -a --format '{{.Names}}' | grep -q "^${{ env.API_CONTAINER }}$"; then
                echo "Stopping API container..."
                docker stop ${{ env.API_CONTAINER }} || true
                docker rm ${{ env.API_CONTAINER }} || true
              fi
              
              # Keep database containers running
              echo "Keeping database containers running for persistence..."
              cd ..
            else
              echo "No current deployment found, proceeding with fresh deployment..."
            fi

            # Enhanced cleanup to prevent port conflicts
            echo "Performing enhanced Docker cleanup to prevent port conflicts..."
            
            # Stop and remove ALL containers that might be using port 8088
            echo "Stopping all containers that might be using port 8088..."
            docker ps --format '{{.Names}}' | while read container; do
              if docker port "$container" 2>/dev/null | grep -q ":8088"; then
                echo "Stopping container using port 8088: $container"
                docker stop "$container" || true
                docker rm "$container" || true
              fi
            done
            
            # Force remove any containers with API-related names
            echo "Force removing any API-related containers..."
            docker ps -a --format '{{.Names}}' | grep -E "(api|worker)" | while read container; do
              echo "Force removing container: $container"
              docker rm -f "$container" || true
            done
            
            # Clean up Docker resources related to the API only
            echo "Cleaning up API Docker resources..."
            docker system prune -f --filter "label=com.docker.compose.service=api"
            
            # Additional cleanup for any containers that might conflict
            echo "Performing additional cleanup..."
            docker system prune -f --volumes=false --filter "until=24h"
            
            # Remove any existing API containers with conflicting names
            if docker ps -a --format '{{.Names}}' | grep -q "^${{ env.API_CONTAINER }}$"; then
              echo "Removing existing API container: ${{ env.API_CONTAINER }}"
              docker rm -f ${{ env.API_CONTAINER }} || true
            fi
            
            # Verify port 8088 is free
            echo "Verifying port 8088 is available..."
            if netstat -tuln 2>/dev/null | grep -q ":8088 "; then
              echo "WARNING: Port 8088 is still in use after cleanup!"
              netstat -tuln | grep ":8088 " || true
              echo "Attempting to kill any processes using port 8088..."
              lsof -ti:8088 | xargs kill -9 2>/dev/null || true
            else
              echo "Port 8088 is available"
            fi

            # Create necessary Docker network if it doesn't exist
            echo "Creating Docker network if it doesn't exist..."
            if ! docker network inspect app-network > /dev/null 2>&1; then
              docker network create app-network --subnet=172.18.0.0/16
            fi

            # Create necessary directories if they don't exist
            mkdir -p current
            mkdir -p releases
            mkdir -p backups

      - name: Prepare deployment files
        run: |
          echo "Preparing files for deployment..."
          echo "Current directory: $PWD"
          echo "GitHub workspace: $GITHUB_WORKSPACE"

          # Create temporary deployment directory
          rm -rf deploy_temp
          mkdir -p deploy_temp

          # Copy required files
          echo "Copying deployment files..."
          cp -r src nginx deploy_temp/
          cp docker-compose.prod.yml .env.production Dockerfile package*.json tsconfig*.json deploy_temp/

          # Copy scripts directory
          echo "Copying scripts..."
          mkdir -p deploy_temp/scripts
          cp -r scripts/* deploy_temp/scripts/
          chmod +x deploy_temp/scripts/*.sh
          
          echo "Deployment files prepared:"
          ls -la deploy_temp/
          echo "Scripts prepared for deployment:"
          ls -la deploy_temp/scripts/
          
          # Verify critical files exist
          if [ ! -f "deploy_temp/docker-compose.prod.yml" ]; then
            echo "❌ ERROR: docker-compose.prod.yml not found in deploy_temp"
            exit 1
          fi
          
          if [ ! -d "deploy_temp/scripts" ]; then
            echo "❌ ERROR: scripts directory not found in deploy_temp"
            exit 1
          fi
          
          echo "✅ All deployment files verified"

      - name: Copy deployment files
        uses: appleboy/scp-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          source: "deploy_temp/*"
          target: "${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}"
          strip_components: 1
          overwrite: true
          rm: false

      - name: Verify deployment files
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Verifying deployment files..."
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            
            echo "Current directory: $(pwd)"
            echo "Directory contents:"
            ls -la
            
            echo "Checking for required files..."
            if [ -f "docker-compose.prod.yml" ]; then
              echo "✅ docker-compose.prod.yml found"
            else
              echo "❌ docker-compose.prod.yml NOT found"
              exit 1
            fi
            
            if [ -d "scripts" ]; then
              echo "✅ scripts directory found"
              echo "Scripts contents:"
              ls -la scripts/
            else
              echo "❌ scripts directory NOT found"
              exit 1
            fi
            
            if [ -f "Dockerfile" ]; then
              echo "✅ Dockerfile found"
            else
              echo "❌ Dockerfile NOT found"
              exit 1
            fi
            
            echo "✅ All required files verified"

      - name: Set up scripts and directories
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          script: |
            echo "Setting up required directories and scripts..."

            # Create required directories with sudo
            sudo mkdir -p /var/www/healthcare/backend/scripts
            sudo mkdir -p /var/log/healthcare
            sudo mkdir -p /var/backups/postgres

            # Copy scripts from the new release
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            if [ -d "scripts" ]; then
              echo "Copying scripts to system locations..."
              sudo cp -r scripts/* /var/www/healthcare/backend/scripts/
              sudo chmod +x /var/www/healthcare/backend/scripts/*.sh
              
              # Set proper ownership
              sudo chown -R ${{ env.SERVER_USER }}:docker /var/www/healthcare/backend/scripts
              sudo chown -R www-data:www-data /var/log/healthcare
              sudo chown -R www-data:www-data /var/backups/postgres
              
              # Set proper permissions
              sudo chmod 755 /var/www/healthcare/backend/scripts
              sudo chmod 755 /var/log/healthcare
              sudo chmod 700 /var/backups/postgres
              
              echo "Scripts setup completed successfully"
            else
              echo "Warning: No scripts directory found in deployment"
            fi

      - name: Setup deployment environment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          timeout: 120s
          proxy_timeout: 120s
          envs: GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,WORKER_COUNT,GITHUB_SHA
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/setup-deployment.sh

      - name: Start containers
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          timeout: 120s
          proxy_timeout: 120s
          envs: GOOGLE_CLIENT_ID,GOOGLE_CLIENT_SECRET,WORKER_COUNT,GITHUB_SHA
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/start-containers.sh

      - name: Configure and optimize
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          timeout: 120s
          proxy_timeout: 120s
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/configure-optimize.sh

      - name: Backup and maintenance
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          timeout: 120s
          proxy_timeout: 120s
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/backup-maintenance.sh

      - name: Health check
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          command_timeout: "30m"
          timeout: 120s
          proxy_timeout: 120s
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/health-check.sh

  post-deployment-verification:
    needs: deploy
    runs-on: ubuntu-latest
    steps:
      - name: Verify domain
        run: |
          echo "Verifying domain resolution for api.ishswami.in..."
          if ! nslookup api.ishswami.in > /dev/null 2>&1; then
            echo "Warning: Domain api.ishswami.in is not resolving"
            echo "Check your DNS configuration"
          fi

      - name: Verify application health
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          timeout: 120s
          proxy_timeout: 120s
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            bash scripts/ci/post-deploy-health-check.sh

      - name: Update deployment status success
        if: success()
        run: |
          echo "Deployment successful"

      - name: Trigger offsite backup
        if: success()
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          timeout: 180s
          command_timeout: "10m"
          proxy_timeout: 180s
          script: |
            cd ${{ env.DEPLOY_PATH }}/releases/${{ github.sha }}
            # Offsite backup is now handled by backup-maintenance.sh
            echo "Offsite backup completed as part of backup-maintenance.sh"

  rollback:
    if: always() && (needs.deploy.result == 'failure' || needs.post-deployment-verification.result == 'failure')
    needs: [deploy, post-deployment-verification, create-deployment]
    runs-on: ubuntu-latest
    steps:
      - name: Rollback deployment
        uses: appleboy/ssh-action@master
        with:
          host: ${{ env.SERVER_IP }}
          username: ${{ env.SERVER_USER }}
          key: ${{ env.SERVER_SSH_KEY }}
          timeout: 120s
          proxy_timeout: 120s
          script: |
            set -e
            cd ${{ env.DEPLOY_PATH }}

            echo "========== ROLLBACK PROCESS STARTED =========="
            echo "Deployment failed. Initiating automatic rollback..."
            echo "Current directory: $(pwd)"
            echo "Listing deployment directory contents:"
            ls -la

            # Check current Docker status
            echo "Current Docker containers:"
            docker ps -a
            echo "Current Docker volumes:"
            docker volume ls

            echo "Checking for rollback script..."
            
            # Try to use the rollback script
            ROLLBACK_SCRIPT_PATHS=(
              "current/scripts/rollback.sh"
              "/var/www/healthcare/backend/scripts/rollback.sh"
              "scripts/rollback.sh"
            )
            
            ROLLBACK_SCRIPT_FOUND=false
            for script_path in "${ROLLBACK_SCRIPT_PATHS[@]}"; do
              if [ -f "$script_path" ]; then
                echo "✅ Rollback script found at: $script_path"
                chmod +x "$script_path"
                
                # Set environment variables for the rollback script
                export DEPLOY_PATH="${{ env.DEPLOY_PATH }}"
                export GOOGLE_CLIENT_ID="${{ env.GOOGLE_CLIENT_ID }}"
                export GOOGLE_CLIENT_SECRET="${{ env.GOOGLE_CLIENT_SECRET }}"
                export WORKER_COUNT="${{ env.WORKER_COUNT }}"
                
                # Run the rollback script
                if "$script_path" auto; then
                  echo "✅ Rollback completed successfully using rollback script"
                  echo "Container status after rollback:"
                  docker ps --format "table {{.Names}}\t{{.Status}}\t{{.Ports}}" || true
                  exit 0
                else
                  ROLLBACK_RESULT=$?
                  echo "❌ Rollback script failed with exit code $ROLLBACK_RESULT"
                  echo "Falling back to emergency rollback procedure"
                  ROLLBACK_SCRIPT_FOUND=true
                  break
                fi
              fi
            done
            
            if [ "$ROLLBACK_SCRIPT_FOUND" = false ]; then
              echo "❌ No rollback script found in any expected location"
              echo "Falling back to emergency rollback procedure"
            fi

            # Manual rollback procedure as fallback
            cd ${{ env.DEPLOY_PATH }}
            echo "Manual rollback procedure starting from: $(pwd)"

            # Ensure backup directory exists
            mkdir -p backups
            echo "Created backups directory if it didn't exist"

            # Check for releases directory
            if [ -d "releases" ]; then
              echo "Releases directory exists, contents:"
              ls -la releases/
            else
              echo "No releases directory found - this may be the first deployment"
              mkdir -p releases
            fi

            # Check if there are any successful deployments
            SUCCESSFUL_DEPLOYMENTS_FILE="${{ env.DEPLOY_PATH }}/successful_deployments.txt"
            if [ -f "$SUCCESSFUL_DEPLOYMENTS_FILE" ]; then
              echo "Found successful deployments record:"
              cat "$SUCCESSFUL_DEPLOYMENTS_FILE"
            else
              echo "No successful deployments record found"
              touch "$SUCCESSFUL_DEPLOYMENTS_FILE"
            fi

            # Check if current deployment exists and is valid
            if [ -L "current" ] && [ -d "$(readlink -f current)" ] && [ -f "$(readlink -f current)/docker-compose.prod.yml" ]; then
              echo "✅ Valid current deployment found, attempting to restore from previous version"
              
              # Enhanced rollback using the rollback script
              echo "Attempting rollback using rollback script..."
              if [ -f "/var/www/healthcare/backend/scripts/rollback.sh" ]; then
                echo "Running automated rollback script..."
                /var/www/healthcare/backend/scripts/rollback.sh auto || {
                  echo "Automated rollback failed, attempting manual rollback..."
                  
                  # Manual rollback fallback
                  if [ -f "$SUCCESSFUL_DEPLOYMENTS_FILE" ]; then
                    # Get the last successful deployment that's not the current one
                    CURRENT_DEPLOY=$(basename $(readlink -f current))
                    echo "Current deployment: $CURRENT_DEPLOY"
                    
                    LAST_SUCCESSFUL=$(grep -v "$CURRENT_DEPLOY" "$SUCCESSFUL_DEPLOYMENTS_FILE" | tail -n 1)
                    echo "Last successful deployment: ${LAST_SUCCESSFUL:-none}"
                    
                    if [ -n "$LAST_SUCCESSFUL" ] && [ -d "releases/$LAST_SUCCESSFUL" ]; then
                      echo "✅ Rolling back to last successful deployment: $LAST_SUCCESSFUL"
                
                  # Stop current API container
                  echo "Stopping current API container..."
                  docker stop latest-api || echo "No API container found to stop"
                  docker rm latest-api || echo "No API container found to remove"
                
                  # Clean up Docker resources specifically for API only
                  echo "Cleaning up API Docker resources..."
                  docker system prune -f --filter "label=com.docker.compose.service=api" || echo "No API resources to prune"
                  
                  # Update symlink to the last successful deployment
                  echo "Updating symlink to point to releases/$LAST_SUCCESSFUL"
                  ln -sfn "releases/$LAST_SUCCESSFUL" current
                  
                  # Start the API from the last successful deployment
                cd current
                  echo "Starting API from previous successful deployment in $(pwd)"
                  
                  # Check if docker-compose.prod.yml exists
                  if [ ! -f "docker-compose.prod.yml" ]; then
                    echo "❌ ERROR: docker-compose.prod.yml not found in $(pwd)"
                    ls -la
                    exit 1
                  fi
                  
                  # Create temporary env file for deployment
                  echo "Setting up environment variables..."
                  echo "GOOGLE_CLIENT_ID=${GOOGLE_CLIENT_ID}" > .env.deploy
                  echo "GOOGLE_CLIENT_SECRET=${GOOGLE_CLIENT_SECRET}" >> .env.deploy
                  
                  # Using --no-deps ensures database containers are not touched
                  echo "Starting API container with environment variables..."
                  docker compose --env-file .env.deploy -f docker-compose.prod.yml up -d --build --no-deps --scale worker=$WORKER_COUNT api worker
                  
                  # Verify deployment
                  echo "Verifying deployment..."
                  if docker exec latest-api env | grep -q "GOOGLE_CLIENT"; then
                    echo "✅ Environment variables verified in container"
                  else
                    echo "❌ WARNING: Google environment variables not found in container"
                    docker logs latest-api --tail 50
                  fi
                  
                  # Cleanup
                  rm -f .env.deploy
                  
                  # Verify the environment variables are set in the container
                  echo "Verifying environment variables in the container..."
                  docker exec latest-api env | grep GOOGLE || echo "❌ Google environment variables not found in container"

                  # Check container logs for any startup issues
                  echo "Checking container logs for startup issues..."
                  docker logs latest-api --tail 50
                  
                  # Verify database containers are still running
                  echo "Verifying database containers are still running..."
                  
                  # Check if any PostgreSQL container is running (safer than exact name matching)
                  if ! docker ps | grep -q "postgres"; then
                    echo "Warning: No PostgreSQL container appears to be running after rollback. Starting it..."
                    docker-compose -f docker-compose.prod.yml up -d --no-recreate postgres
                  else
                    echo "PostgreSQL container appears to be running."
                  fi
                  
                  # Check if any Redis container is running (safer than exact name matching)
                  if ! docker ps | grep -q "redis" | grep -v "commander"; then
                    echo "Warning: No Redis container appears to be running after rollback. Starting it..."
                    docker-compose -f docker-compose.prod.yml up -d --no-recreate redis
                  else
                    echo "Redis container appears to be running."
                  fi
                  
                  # Show container status
                  echo "Container status after rollback:"
                  docker ps
                  
                  # Wait for API to be healthy with timeout protection
                echo "Waiting for API to be healthy..."
                  for i in {1..10}; do
                    echo "Health check attempt $i/10..."
                    HEALTH_OUTPUT=$(timeout 5 curl -v --max-time 5 http://localhost:8088/health 2>&1 || echo "Connection failed")
                    echo "$HEALTH_OUTPUT"
                    
                    if echo "$HEALTH_OUTPUT" | grep -q "< HTTP/1.1 200 OK\|< HTTP/2 200"; then
                      echo "✅ API is healthy after rollback (HTTP 200)"
                      exit 0
                    elif echo "$HEALTH_OUTPUT" | grep -q "ok\|status.*up\|\"status\":\"ok\"\|\"status\": \"ok\""; then
                      echo "✅ API is healthy after rollback (status indicators)"
                      exit 0
                    fi
                    
                    echo "Waiting 5 seconds before next health check..."
                    sleep 5
                  done
                  
                  echo "⚠️ API health check didn't pass, but container is running"
                  echo "Final container status:"
                  docker ps
                  echo "API logs:"
                  docker logs latest-api --tail 20
                  exit 0
                else
                  echo "❌ No valid previous successful deployment found to roll back to"
                fi
              fi
              
              # If we get here, no valid last successful deployment was found
              echo "Checking for backup to use..."
              
              # List backups
              echo "Available backups:"
              ls -la backups/
              
              # Fall back to using the backup
              if [ -f backups/latest_backup ]; then
                timestamp=$(cat backups/latest_backup)
                echo "✅ Rolling back to backup from $timestamp"
                
                # Stop current API container
                echo "Stopping current API container..."
                docker stop latest-api || echo "No API container found to stop"
                docker rm latest-api || echo "No API container found to remove"
                
                # Clean up Docker resources specifically for API
                echo "Cleaning up API Docker resources..."
                docker system prune -f --filter "label=com.docker.compose.service=api" || echo "No API resources to prune"
                
                # Restore from backup
                echo "Restoring from backup..."
                rm -rf current_old || true
                mv current current_old || true
                mkdir -p current
                cp -r "backups/$timestamp/"* current/
                
                # Start API from backup
                cd current
                echo "Starting API from backup in $(pwd)"
                
                if [ ! -f "docker-compose.prod.yml" ]; then
                  echo "❌ ERROR: docker-compose.prod.yml not found in restored backup"
                  ls -la
                  exit 1
                fi
                
                echo "Starting API container from backup..."
                docker-compose -f docker-compose.prod.yml up -d --build --no-deps --scale worker=$WORKER_COUNT api worker
                
                # Show container status
                echo "Container status after backup restoration:"
                docker ps
                
                echo "Rollback completed successfully using backup"
                exit 0
              else
                echo "⚠️ No backup found for rollback, but current deployment exists"
                echo "No action taken - keeping current deployment"
                echo "Current container status:"
                docker ps
                exit 0
              fi
            else
              echo "⚠️ No valid current deployment found"
              echo "Filesystem state:"
              ls -la
              
              if [ -L "current" ]; then
                echo "Current symlink points to: $(readlink -f current 2>/dev/null || echo 'invalid destination')"
              else
                echo "No current symlink exists"
              fi
              
              echo "Docker container status:"
              docker ps -a
              
              echo "No rollback action possible without valid current deployment"
              exit 0
            fi

      - name: Update deployment status success
        if: success()
        run: |
          echo "Rollback successful"

      - name: Update deployment status failure
        if: failure()
        run: |
          echo "Rollback failed"

// Import PrismaClient - use adapter pattern for Prisma 7 with engine type "client"
// Import from generated client to ensure type compatibility with Prisma 7
// Prisma Client is generated by Dockerfile during Docker builds, or by postinstall script locally
// Note: This file is excluded from TypeScript checking in tsconfig.json
import { PrismaClient } from '@prisma/client';
import { PrismaPg } from '@prisma/adapter-pg';
import { Pool } from 'pg';
import { faker } from '@faker-js/faker';
import * as bcrypt from 'bcryptjs'; // Use bcryptjs to match AuthService
import * as fs from 'fs';
import * as path from 'path';
import { createRequire } from 'module';

// Use __filename for CommonJS compatibility (ts-node uses CommonJS)
// Note: Reserved for future use if dynamic module loading is needed
const _requireModule = createRequire(__filename);
// Import enums from centralized location
import {
  PaymentStatus,
  PaymentMethod,
  MedicineType,
  QueueStatus,
  AppointmentStatus,
  AppointmentType,
  Prakriti,
  Dosha,
} from '@core/types/enums.types';
import type { Role } from '@core/types/rbac.types';
// Import entity types from centralized types for proper type annotations
import type { RbacRoleEntity, UserRoleEntity } from '@core/types';
import { Gender } from '@dtos/user.dto';
// Use helper functions (which use dotenv) for environment variable access
// These mimic ConfigService methods but work in seed scripts
import { getEnvWithDefault, isProduction, isDevelopment } from '@config/environment/utils';

// Role string literals (Role is a type, not an enum)
const RoleValues = {
  SUPER_ADMIN: 'SUPER_ADMIN' as const,
  CLINIC_ADMIN: 'CLINIC_ADMIN' as const,
  DOCTOR: 'DOCTOR' as const,
  PATIENT: 'PATIENT' as const,
  RECEPTIONIST: 'RECEPTIONIST' as const,
  PHARMACIST: 'PHARMACIST' as const,
  THERAPIST: 'THERAPIST' as const,
  LAB_TECHNICIAN: 'LAB_TECHNICIAN' as const,
  FINANCE_BILLING: 'FINANCE_BILLING' as const,
  SUPPORT_STAFF: 'SUPPORT_STAFF' as const,
  NURSE: 'NURSE' as const,
  COUNSELOR: 'COUNSELOR' as const,
  // LOCATION_HEAD is not in Role enum yet, will be added in future migration
  // LOCATION_HEAD: 'LOCATION_HEAD' as const,
} satisfies Record<string, Role>;

const SEED_COUNT = 50;

// Clinic ID counter for sequential generation (CL0001, CL0002, etc.)
// Starts at 2 to ensure Aadesh Ayurvedalay gets CL0002
let clinicIdCounter = 2;

/**
 * Generate sequential clinic ID in format CL0001, CL0002, etc.
 * Format matches ClinicService.generateNextClinicId() implementation
 */
function generateClinicId(): string {
  return `CL${String(clinicIdCounter++).padStart(4, '0')}`;
}

// Initialize Prisma client with adapter (required for Prisma 7 with engine type "client")
// Use helper functions (which use dotenv) for environment variable access
const connectionString =
  getEnvWithDefault('DIRECT_URL', '') || getEnvWithDefault('DATABASE_URL', '');
if (!connectionString) {
  throw new Error('DATABASE_URL or DIRECT_URL environment variable is required');
}

const poolConfig: {
  connectionString: string;
  ssl?: boolean | { rejectUnauthorized: boolean };
  max?: number;
  connectionTimeoutMillis?: number;
} = {
  connectionString,
  max: 10,
  connectionTimeoutMillis: 10000,
};

const prodEnv = isProduction();
if (connectionString.includes('supabase') || connectionString.includes('pooler.supabase.com')) {
  poolConfig.ssl = prodEnv ? { rejectUnauthorized: true } : { rejectUnauthorized: false };
}

console.log('Initializing PrismaClient with adapter...');
const pool = new Pool(poolConfig);
const adapter = new PrismaPg(pool);

// Create PrismaClient with adapter - simplified initialization
// Clear require cache to ensure fresh PrismaClient
try {
  // Use dynamic import path - TypeScript cannot resolve at compile time
  // Type assertion is safe because we verify the module exists at runtime
  const modulePath = require.resolve('./generated/client/index.js' as string);
  delete require.cache[modulePath];
  Object.keys(require.cache).forEach(key => {
    if (key.includes('prisma') || key.includes('.prisma')) {
      delete require.cache[key];
    }
  });
} catch {
  // Module not in cache yet, that's fine
}

const prismaConstructorArgs = {
  // Use helper functions (which use dotenv) for environment variable access
  log: (isDevelopment() ? ['error', 'warn'] : ['error']) as Array<'error' | 'warn'>,
  errorFormat: 'minimal' as const,
  adapter: adapter,
};

console.log('Creating PrismaClient instance...');
// Explicit type annotation ensures TypeScript can properly infer PrismaClient methods
const prisma: PrismaClient = new PrismaClient(prismaConstructorArgs);
console.log('PrismaClient initialized successfully');

let userIdCounter = 1;
const generateUserId = () => `UID${String(userIdCounter++).padStart(6, '0')}`;

let locationIdCounter = 1;
const generateLocationId = () => `LOC${String(locationIdCounter++).padStart(4, '0')}`;

/**
 * Export test IDs to a JSON file for use in testing scripts
 */
function exportTestIds(testIds: Record<string, unknown>) {
  const testIdsPath = path.join(process.cwd(), 'test-ids.json');
  try {
    fs.writeFileSync(testIdsPath, JSON.stringify(testIds, null, 2), 'utf-8');
    console.log(`\n✓ Test IDs exported to: ${testIdsPath}`);
    console.log('You can now use these IDs in your test scripts:');
    console.log('  - TEST_CLINIC_ID=' + String((testIds['clinics'] as string[])[0]));
    console.log('  - TEST_DOCTOR_ID=' + String(testIds['demoDoctorId']));
    console.log('  - TEST_PATIENT_ID=' + String(testIds['demoPatientId']));
  } catch (error) {
    console.error('Failed to export test IDs:', error);
  }
}

/**
 * Helper function to assign RBAC role to user
 * Creates role if it doesn't exist, then assigns it to the user
 */
async function assignRoleToUser(userId: string, roleName: string, clinicId: string): Promise<void> {
  try {
    // Find or create RBAC role
    let rbacRole: RbacRoleEntity | null = (await prisma.rbacRole.findFirst({
      where: {
        name: roleName,
        domain: 'healthcare',
        clinicId: null, // System roles have null clinicId
      },
    })) as RbacRoleEntity | null;

    if (!rbacRole) {
      console.log(`Creating RBAC role: ${roleName}...`);
      rbacRole = (await prisma.rbacRole.create({
        data: {
          name: roleName,
          displayName: roleName.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase()),
          description: `${roleName} role`,
          domain: 'healthcare',
          clinicId: null, // System role
          isSystemRole: true,
          isActive: true,
        },
      })) as RbacRoleEntity;
      console.log(`✓ Created RBAC role: ${roleName}`);
    }

    // Check if role is already assigned
    const existingAssignmentResult = await prisma.userRole.findFirst({
      where: {
        userId,
        roleId: rbacRole.id,
        clinicId,
        isActive: true,
      },
    });
    // Convert Prisma result to UserRoleEntity (handle JsonValue to Record conversion)
    const existingAssignment: UserRoleEntity | null = existingAssignmentResult
      ? ({
          ...existingAssignmentResult,
          permissions:
            existingAssignmentResult.permissions &&
            typeof existingAssignmentResult.permissions === 'object'
              ? (existingAssignmentResult.permissions as Record<string, never>)
              : null,
          schedule:
            existingAssignmentResult.schedule &&
            typeof existingAssignmentResult.schedule === 'object'
              ? (existingAssignmentResult.schedule as Record<string, never>)
              : null,
        } as UserRoleEntity)
      : null;

    if (!existingAssignment) {
      console.log(`Assigning RBAC role ${roleName} to user ${userId}...`);
      await prisma.userRole.create({
        data: {
          userId,
          roleId: rbacRole.id,
          clinicId,
          assignedBy: 'SYSTEM',
          isActive: true,
          isPrimary: true, // Primary role for the user
        },
      });
      console.log(`✓ Assigned RBAC role ${roleName} to user`);
    } else {
      console.log(`✓ RBAC role ${roleName} already assigned to user`);
    }
  } catch (error) {
    console.error(`Failed to assign role ${roleName} to user ${userId}:`, error);
    // Don't throw - allow seed to continue even if role assignment fails
  }
}

/**
 * Quick seed - creates only demo users if clinics exist
 * Enhanced to also create clinic locations if missing
 */
async function quickSeed() {
  try {
    console.log('Starting quick seed...');
    const clinic = await prisma.clinic.findFirst({});
    if (!clinic) {
      throw new Error('Clinic not found');
    }
    console.log(`Using clinic: ${clinic.name} (Clinic ID: ${clinic.clinicId})`);

    // Ensure clinic has at least one location (required for appointments)
    let clinicLocation = await prisma.clinicLocation.findFirst({
      where: { clinicId: clinic.id },
    });

    if (!clinicLocation) {
      console.log('Creating clinic location...');
      clinicLocation = await prisma.clinicLocation.create({
        data: {
          name: `${clinic.name} Main Branch`,
          address: 'Main Street',
          city: 'Pune',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '411001',
          phone: clinic.phone || '+91-9876543210',
          email: clinic.email || 'main@clinic.com',
          clinicId: clinic.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      });
      console.log(`✓ Created clinic location: ${clinicLocation.name}`);
    } else {
      console.log(`✓ Clinic location already exists: ${clinicLocation.name}`);
    }

    // Create demo patient if missing
    let demoPatient = await prisma.user.findUnique({
      where: { email: 'patient1@example.com' },
    });

    if (!demoPatient) {
      console.log('Creating demo patient...');
      const hashedPassword = await bcrypt.hash('test1234', 12); // Use 12 rounds to match AuthService
      console.log('Password hashed, creating user...');
      demoPatient = await prisma.user.create({
        data: {
          email: 'patient1@example.com',
          password: hashedPassword,
          name: 'Demo Patient',
          age: 30,
          firstName: 'Demo',
          lastName: 'Patient',
          phone: '9000000003',
          role: RoleValues.PATIENT,
          gender: Gender.OTHER,
          isVerified: true,
          userid: generateUserId(),
          clinics: { connect: { id: clinic.id } },
          primaryClinicId: clinic.id,
        },
      });
      console.log(`User created with ID: ${demoPatient.id}`);
      console.log('Creating patient record...');
      await prisma.patient.create({
        data: {
          userId: demoPatient.id,
          prakriti: Prakriti.VATA,
          dosha: Dosha.PITTA,
        },
      });
      // Double-check clinic association was created
      const patientClinicCheck = await prisma.user.findUnique({
        where: { id: demoPatient.id },
        include: { clinics: true },
      });
      // Type assertion needed because Prisma types may not be available at compile time
      const clinics = (patientClinicCheck?.clinics || []) as Array<{ id: string }>;
      if (!clinics.some((c: { id: string }) => c.id === clinic.id)) {
        console.log('Ensuring patient-clinic association...');
        await prisma.user.update({
          where: { id: demoPatient.id },
          data: {
            clinics: { connect: { id: clinic.id } },
            primaryClinicId: clinic.id,
          },
        });
      }
      // Assign RBAC role to patient
      await assignRoleToUser(demoPatient.id, RoleValues.PATIENT, clinic.id);
      console.log(`✓ Created demo patient: ${demoPatient.email}`);
    } else {
      console.log(`✓ Demo patient already exists: patient1@example.com`);
      // Fix password if it's incorrect
      const hashedPassword = await bcrypt.hash('test1234', 12);
      await prisma.user.update({
        where: { email: 'patient1@example.com' },
        data: { password: hashedPassword },
      });
      console.log('✓ Updated patient password');
      // Ensure patient is associated with clinic
      const patientClinics = await prisma.user.findUnique({
        where: { email: 'patient1@example.com' },
        include: { clinics: true },
      });
      // Type assertion needed because Prisma types may not be available at compile time
      const patientClinicsList = (patientClinics?.clinics || []) as Array<{ id: string }>;
      if (!patientClinicsList.some((c: { id: string }) => c.id === clinic.id)) {
        console.log('Associating patient with clinic...');
        await prisma.user.update({
          where: { id: demoPatient.id },
          data: {
            clinics: { connect: { id: clinic.id } },
            primaryClinicId: clinic.id,
          },
        });
        console.log('✓ Patient associated with clinic');
      }
      // Ensure RBAC role is assigned
      await assignRoleToUser(demoPatient.id, RoleValues.PATIENT, clinic.id);
    }

    // Create demo doctor if missing
    let demoDoctor = await prisma.user.findUnique({
      where: { email: 'doctor1@example.com' },
    });

    if (!demoDoctor) {
      console.log('Creating demo doctor...');
      const hashedPassword = await bcrypt.hash('test1234', 12); // Use 12 rounds to match AuthService
      console.log('Password hashed, creating user...');
      demoDoctor = await prisma.user.create({
        data: {
          email: 'doctor1@example.com',
          password: hashedPassword,
          name: 'Demo Doctor',
          age: 45,
          firstName: 'Demo',
          lastName: 'Doctor',
          phone: '9000000002',
          role: RoleValues.DOCTOR,
          gender: Gender.FEMALE,
          isVerified: true,
          userid: generateUserId(),
          clinics: { connect: { id: clinic.id } },
          primaryClinicId: clinic.id,
        },
      });
      console.log(`User created with ID: ${demoDoctor.id}`);
      // Ensure clinic association is created (sometimes Prisma doesn't create the junction table entry)
      const doctorClinicCheckAfterCreate = await prisma.user.findUnique({
        where: { id: demoDoctor.id },
        include: { clinics: true },
      });
      // Type assertion needed because Prisma types may not be available at compile time
      const doctorClinicsAfterCreate = (doctorClinicCheckAfterCreate?.clinics || []) as Array<{
        id: string;
      }>;
      if (!doctorClinicsAfterCreate.some((c: { id: string }) => c.id === clinic.id)) {
        console.log('Ensuring doctor-clinic association...');
        await prisma.user.update({
          where: { id: demoDoctor.id },
          data: {
            clinics: { connect: { id: clinic.id } },
            primaryClinicId: clinic.id,
          },
        });
      }
      console.log('Creating doctor record...');
      await prisma.doctor.create({
        data: {
          id: demoDoctor.id,
          userId: demoDoctor.id,
          specialization: 'General Medicine',
          experience: 10,
          qualification: 'MBBS',
          rating: 4.5,
          isAvailable: true,
          consultationFee: 1000,
        },
      });
      console.log('Creating doctor-clinic relationship...');
      await prisma.doctorClinic.create({
        data: {
          doctorId: demoDoctor.id,
          clinicId: clinic.id,
          locationId: clinicLocation.id,
          startTime: new Date(),
          endTime: new Date(),
        },
      });
      // Assign RBAC role to doctor
      await assignRoleToUser(demoDoctor.id, RoleValues.DOCTOR, clinic.id);
      console.log(`✓ Created demo doctor: ${demoDoctor.email}`);
    } else {
      console.log(`✓ Demo doctor already exists: doctor1@example.com`);
      // Fix password if it's incorrect
      const hashedPassword = await bcrypt.hash('test1234', 12);
      await prisma.user.update({
        where: { email: 'doctor1@example.com' },
        data: { password: hashedPassword },
      });
      console.log('✓ Updated doctor password');
      // Ensure doctor is associated with clinic
      const doctorClinics = await prisma.user.findUnique({
        where: { email: 'doctor1@example.com' },
        include: { clinics: true },
      });
      // Type assertion needed because Prisma types may not be available at compile time
      const doctorClinicsList = (doctorClinics?.clinics || []) as Array<{ id: string }>;
      if (!doctorClinicsList.some((c: { id: string }) => c.id === clinic.id)) {
        console.log('Associating doctor with clinic...');
        await prisma.user.update({
          where: { id: demoDoctor.id },
          data: {
            clinics: { connect: { id: clinic.id } },
            primaryClinicId: clinic.id,
          },
        });
        console.log('✓ Doctor associated with clinic');
      }
      // Ensure doctor record exists
      const doctorRecord = await prisma.doctor.findUnique({
        where: { userId: demoDoctor.id },
      });
      if (!doctorRecord) {
        console.log('Creating doctor record...');
        await prisma.doctor.create({
          data: {
            id: demoDoctor.id,
            userId: demoDoctor.id,
            specialization: 'General Medicine',
            experience: 10,
            qualification: 'MBBS',
            rating: 4.5,
            isAvailable: true,
            consultationFee: 1000,
          },
        });
        console.log('✓ Doctor record created');
      }
      // Ensure doctor-clinic relationship exists
      const doctorClinicRel = await prisma.doctorClinic.findFirst({
        where: {
          doctorId: demoDoctor.id,
          clinicId: clinic.id,
        },
      });
      if (!doctorClinicRel) {
        console.log('Creating doctor-clinic relationship...');
        await prisma.doctorClinic.create({
          data: {
            doctorId: demoDoctor.id,
            clinicId: clinic.id,
            locationId: clinicLocation.id,
            startTime: new Date(),
            endTime: new Date(),
          },
        });
        console.log('✓ Doctor-clinic relationship created');
      }
      // Ensure RBAC role is assigned
      await assignRoleToUser(demoDoctor.id, RoleValues.DOCTOR, clinic.id);
    }

    console.log('\n✓ Quick seed completed!');
    console.log('Test credentials:');
    console.log('  Patient: patient1@example.com / test1234');
    console.log('  Doctor:  doctor1@example.com / test1234');
    console.log(`  Clinic ID: ${clinic.id}`);
    console.log(`  Location ID: ${clinicLocation.id}`);
  } catch (error) {
    console.error('Error in quickSeed:', error);
    if (error instanceof Error) {
      console.error('Error message:', error.message);
      console.error('Error stack:', error.stack);
    }
    throw error;
  }
}

/**
 * Create initial clinic and super admin if they don't exist
 */
async function createClinicIfNeeded() {
  // Create super admin first if needed
  let superAdmin = await prisma.user.findFirst({
    where: { role: RoleValues.SUPER_ADMIN },
  });

  if (!superAdmin) {
    console.log('Creating super admin...');
    const hashedPassword = await bcrypt.hash('admin123', 12); // Use 12 rounds to match AuthService
    superAdmin = await prisma.user.create({
      data: {
        email: 'admin@example.com',
        password: hashedPassword,
        name: 'Admin User',
        age: 30,
        firstName: 'Admin',
        lastName: 'User',
        phone: '1234567890',
        role: RoleValues.SUPER_ADMIN,
        gender: Gender.MALE,
        isVerified: true,
        userid: generateUserId(),
      },
    });
    await prisma.superAdmin.create({
      data: { userId: superAdmin.id },
    });
    console.log('✓ Super admin created');
  }

  // Create clinic
  console.log('Creating initial clinic...');
  const clinic = await prisma.clinic.create({
    data: {
      name: 'Aadesh Ayurvedalay',
      address: 'Pune, Maharashtra',
      phone: '+91-9876543210',
      email: 'contact@aadesh.com',
      app_name: 'aadesh_ayurvedalay',
      // Use helper functions (which use dotenv) for environment variable access
      db_connection_string: getEnvWithDefault('DATABASE_URL', ''),
      databaseName: 'userdb',
      createdByUser: {
        connect: { id: superAdmin.id },
      },
      clinicId: 'CL0002',
      subdomain: 'aadesh',
      isActive: true,
    },
  });

  console.log(`✓ Clinic created: ${clinic.name} (Clinic ID: ${clinic.clinicId})`);
  return clinic;
}

async function main() {
  try {
    console.log('=== Starting seed script ===');
    await waitForDatabase();
    console.log('Database connection verified');

    // Auto-detect scenario: check if clinics exist
    console.log('Checking for existing clinics...');
    const existingClinics = await prisma.clinic.findMany({ take: 1 });
    console.log(`Found ${existingClinics.length} clinic(s)`);

    if (existingClinics.length === 0) {
      // No clinics exist - create initial clinic and super admin
      console.log('No clinics found. Creating initial clinic and super admin...');
      await createClinicIfNeeded();
      console.log('\n✓ Initial setup complete. Run "yarn seed:dev" again for full data seeding.');
      return;
    }

    // Check if demo users already exist (quick seed scenario)
    console.log('Checking for existing demo users...');
    const existingDemoPatient = await prisma.user.findUnique({
      where: { email: 'patient1@example.com' },
    });
    const existingDemoDoctor = await prisma.user.findUnique({
      where: { email: 'doctor1@example.com' },
    });

    console.log(`Patient exists: ${!!existingDemoPatient}`);
    console.log(`Doctor exists: ${!!existingDemoDoctor}`);

    if (!existingDemoPatient || !existingDemoDoctor) {
      // Clinics exist but demo users don't - quick seed
      console.log('Clinics found but demo users missing. Running quick seed...');
      try {
        await quickSeed();
        console.log('\n✓ Quick seed completed successfully!');
        console.log(
          'Demo users created. Run "yarn seed:dev" again for full data seeding (50 users per role).'
        );
        return;
      } catch (error) {
        console.error('\n✗ Quick seed failed:', error);
        if (error instanceof Error) {
          console.error('Error message:', error.message);
        }
        console.error('Falling back to full seed...');
        // Fall through to full seed if quick seed fails
      }
    } else {
      console.log('✓ Demo users already exist. Skipping quick seed.');
      console.log(
        'To run full seed with 50 users per role, delete demo users first or run with FORCE_FULL_SEED=true'
      );
    }

    // Full seed scenario - clean and seed everything
    console.log('Cleaning database...');
    await cleanDatabase();

    console.log('Starting comprehensive database seeding...');

    // Declare checkInLocations at function scope for use in testIds export
    let checkInLocations: Array<{ id: string }> = [];

    // ===== SUPER ADMIN CREATION =====
    console.log('Creating SuperAdmin user...');
    const hashedPassword = await bcrypt.hash('admin123', 12); // Use 12 rounds to match AuthService

    const superAdminUser = (await (prisma.user.create({
      data: {
        email: 'admin@example.com',
        password: hashedPassword,
        name: 'Admin User',
        age: 30,
        firstName: 'Admin',
        lastName: 'User',
        phone: '1234567890',
        role: RoleValues.SUPER_ADMIN,
        gender: Gender.MALE,
        isVerified: true,
        userid: generateUserId(),
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    (await (prisma.superAdmin.create({
      data: {
        userId: superAdminUser.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // ===== CLINIC CREATION =====
    console.log('Creating clinics...');

    // Aadesh Ayurvedalay - Clinic ID: CL0002
    const clinic1 = (await (prisma.clinic.create({
      data: {
        name: 'Aadesh Ayurvedalay',
        address: 'Pune, Maharashtra',
        phone: '+91-9876543210',
        email: 'contact@aadesh.com',
        app_name: 'aadesh_ayurvedalay',
        // Use helper functions (which use dotenv) for environment variable access
        db_connection_string:
          getEnvWithDefault('DATABASE_URL', '') ||
          'postgresql://postgres:postgres@postgres:5432/userdb?schema=public',
        databaseName: 'userdb',
        createdByUser: {
          connect: { id: superAdminUser.id },
        },
        clinicId: generateClinicId(), // CL0002 - Aadesh Ayurvedalay
        subdomain: 'aadesh',
        isActive: true,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    console.log(`✓ Aadesh Ayurvedalay created with Clinic ID: CL0002`);

    // Shri Vishwamurti Ayurvedalay - Clinic ID: CL0003
    const clinic2 = (await (prisma.clinic.create({
      data: {
        name: 'Shri Vishwamurti Ayurvedalay',
        address: 'Mumbai, Maharashtra',
        phone: '+91-8765432109',
        email: 'contact@Vishwamurti.com',
        app_name: 'Vishwamurti_ayurvedalay',
        // Use helper functions (which use dotenv) for environment variable access
        db_connection_string:
          getEnvWithDefault('DATABASE_URL', '') ||
          'postgresql://postgres:postgres@postgres:5432/userdb?schema=public',
        databaseName: 'userdb',
        createdByUser: {
          connect: { id: superAdminUser.id },
        },
        clinicId: generateClinicId(), // CL0003 - Shri Vishwamurti Ayurvedalay
        subdomain: 'Vishwamurti',
        isActive: true,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    console.log(`✓ Shri Vishwamurti Ayurvedalay created with Clinic ID: CL0003`);

    // Create clinic locations
    console.log('Creating clinic locations...');
    // Aadesh Ayurvedalay Locations
    const clinic1Locations = (await Promise.all([
      prisma.clinicLocation.create({
        data: {
          name: 'Aadesh Main Branch',
          address: 'Koregaon Park, Pune',
          city: 'Pune',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '411001',
          phone: '+91-9876543210',
          email: 'main@aadesh.com',
          clinicId: clinic1.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
      prisma.clinicLocation.create({
        data: {
          name: 'Aadesh North Branch',
          address: 'Baner Road, Pune',
          city: 'Pune',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '411045',
          phone: '+91-9876543211',
          email: 'north@aadesh.com',
          clinicId: clinic1.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
      prisma.clinicLocation.create({
        data: {
          name: 'Aadesh South Branch',
          address: 'Sinhagad Road, Pune',
          city: 'Pune',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '411041',
          phone: '+91-9876543212',
          email: 'south@aadesh.com',
          clinicId: clinic1.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
    ])) as unknown as Array<{ id: string }>;

    // Vishwamurti Ayurvedalay Locations
    const clinic2Locations = (await Promise.all([
      prisma.clinicLocation.create({
        data: {
          name: 'Vishwamurti Main Branch',
          address: 'Juhu, Mumbai',
          city: 'Mumbai',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '400049',
          phone: '+91-8765432109',
          email: 'main@Vishwamurti.com',
          clinicId: clinic2.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
      prisma.clinicLocation.create({
        data: {
          name: 'Vishwamurti Andheri Branch',
          address: 'Andheri East, Mumbai',
          city: 'Mumbai',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '400069',
          phone: '+91-8765432108',
          email: 'andheri@Vishwamurti.com',
          clinicId: clinic2.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
      prisma.clinicLocation.create({
        data: {
          name: 'Vishwamurti Powai Branch',
          address: 'Powai, Mumbai',
          city: 'Mumbai',
          state: 'Maharashtra',
          country: 'India',
          zipCode: '400076',
          phone: '+91-8765432107',
          email: 'powai@Vishwamurti.com',
          clinicId: clinic2.id,
          locationId: generateLocationId(),
          isActive: true,
        },
      }) as unknown as Promise<{ id: string }>,
    ])) as unknown as Array<{ id: string }>;

    // Create a default clinic admin
    console.log('Creating default clinic admin...');
    const clinicAdminUser = (await (prisma.user.create({
      data: {
        email: 'clinicadmin@example.com',
        password: await bcrypt.hash('admin123', 12), // Use 12 rounds to match AuthService
        name: 'Clinic Admin',
        age: 35,
        firstName: 'Clinic',
        lastName: 'Admin',
        phone: '9876543210',
        role: RoleValues.CLINIC_ADMIN,
        gender: Gender.MALE,
        isVerified: true,
        userid: generateUserId(),
        clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
        primaryClinicId: clinic1.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    (await (prisma.clinicAdmin.create({
      data: {
        userId: clinicAdminUser.id,
        clinicId: clinic1.id,
        isOwner: true,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // ===== CLINIC ADMIN DEMO USER =====
    const demoClinicAdmin = (await (prisma.user.create({
      data: {
        email: 'clinicadmin1@example.com',
        password: await bcrypt.hash('test1234', 12), // Use 12 rounds to match AuthService
        name: 'Demo Clinic Admin',
        age: 40,
        firstName: 'Demo',
        lastName: 'ClinicAdmin',
        phone: '9000000001',
        role: RoleValues.CLINIC_ADMIN,
        gender: Gender.MALE,
        isVerified: true,
        userid: generateUserId(),
        clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
        primaryClinicId: clinic1.id,
      },
    }) as unknown as Promise<{ id: string; role: string }>)) as unknown as {
      id: string;
      role: string;
    };
    (await (prisma.clinicAdmin.create({
      data: {
        userId: demoClinicAdmin.id,
        clinicId: clinic1.id,
        isOwner: false,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // Create Users with different roles
    console.log('Creating users...');
    const users = (await Promise.all([
      // Clinic Admins
      ...Array(SEED_COUNT)
        .fill(null)
        .map(
          (_, i) =>
            prisma.user.create({
              data: {
                email: faker.internet.email(),
                password: faker.internet.password(),
                name: faker.person.fullName(),
                age: faker.number.int({ min: 30, max: 70 }),
                firstName: faker.person.firstName(),
                lastName: faker.person.lastName(),
                phone: faker.phone.number(),
                role: RoleValues.CLINIC_ADMIN,
                gender: faker.helpers.arrayElement(Object.values(Gender)),
                isVerified: true,
                userid: generateUserId(),
                clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
                primaryClinicId: i % 2 === 0 ? clinic1.id : clinic2.id,
              },
            }) as unknown as Promise<{ id: string; role: string }>
        ),

      // Doctors
      ...Array(SEED_COUNT)
        .fill(null)
        .map(
          (_, i) =>
            prisma.user.create({
              data: {
                email: faker.internet.email(),
                password: faker.internet.password(),
                name: faker.person.fullName(),
                age: faker.number.int({ min: 30, max: 70 }),
                firstName: faker.person.firstName(),
                lastName: faker.person.lastName(),
                phone: faker.phone.number(),
                role: RoleValues.DOCTOR,
                gender: faker.helpers.arrayElement(Object.values(Gender)),
                isVerified: true,
                userid: generateUserId(),
                clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
                primaryClinicId: i % 2 === 0 ? clinic1.id : clinic2.id,
              },
            }) as unknown as Promise<{ id: string; role: string }>
        ),

      // Patients
      ...Array(SEED_COUNT)
        .fill(null)
        .map(
          (_, i) =>
            prisma.user.create({
              data: {
                email: faker.internet.email(),
                password: faker.internet.password(),
                name: faker.person.fullName(),
                age: faker.number.int({ min: 12, max: 80 }),
                firstName: faker.person.firstName(),
                lastName: faker.person.lastName(),
                phone: faker.phone.number(),
                role: RoleValues.PATIENT,
                gender: faker.helpers.arrayElement(Object.values(Gender)),
                isVerified: true,
                userid: generateUserId(),
                clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
                primaryClinicId: i % 2 === 0 ? clinic1.id : clinic2.id,
              },
            }) as unknown as Promise<{ id: string; role: string }>
        ),

      // Receptionists
      ...Array(SEED_COUNT)
        .fill(null)
        .map(
          (_, i) =>
            prisma.user.create({
              data: {
                email: faker.internet.email(),
                password: faker.internet.password(),
                name: faker.person.fullName(),
                age: faker.number.int({ min: 20, max: 50 }),
                firstName: faker.person.firstName(),
                lastName: faker.person.lastName(),
                phone: faker.phone.number(),
                role: RoleValues.RECEPTIONIST,
                gender: faker.helpers.arrayElement(Object.values(Gender)),
                isVerified: true,
                userid: generateUserId(),
                clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
                primaryClinicId: i % 2 === 0 ? clinic1.id : clinic2.id,
              },
            }) as unknown as Promise<{ id: string; role: string }>
        ),
    ])) as unknown as Array<{ id: string; role: string }>;

    // Create ClinicAdmins with clinic associations
    console.log('Creating clinic admins...');
    const clinicAdminUsers = users.filter(
      (u): u is { id: string; role: string } => u.role === RoleValues.CLINIC_ADMIN
    );
    await Promise.all(
      clinicAdminUsers.map((user, index) => {
        const clinicId = index % 2 === 0 ? clinic1.id : clinic2.id;
        return prisma.clinicAdmin.create({
          data: {
            userId: user.id,
            clinicId: clinicId,
            isOwner: index < 2, // First admin for each clinic is owner
          },
        }) as unknown as Promise<{ id: string }>;
      })
    );

    // Create Doctors with clinic and location associations
    console.log('Creating doctors...');
    const doctorUsers = users.filter(
      (u): u is { id: string; role: string } => u.role === RoleValues.DOCTOR
    );
    const doctors = (await Promise.all(
      doctorUsers.map(
        user =>
          prisma.doctor.create({
            data: {
              id: user.id,
              userId: user.id,
              specialization: faker.person.jobTitle(),
              experience: faker.number.int({ min: 1, max: 30 }),
              qualification: faker.person.jobType(),
              rating: faker.number.float({ min: 3, max: 5, fractionDigits: 1 }),
              isAvailable: true,
              consultationFee: faker.number.float({
                min: 500,
                max: 2000,
                fractionDigits: 2,
              }),
            },
          }) as unknown as Promise<{ id: string }>
      )
    )) as unknown as Array<{ id: string }>;

    // Create DoctorClinic relationships with locations
    console.log('Creating doctor-clinic relationships...');

    // Prepare doctor-clinic relationships data - one relationship per doctor per clinic
    const doctorClinicData = doctors.flatMap(doctor => [
      // Connect doctor to Aadesh clinic with a random location
      {
        doctorId: doctor.id,
        clinicId: clinic1.id,
        locationId:
          clinic1Locations.length > 0
            ? (clinic1Locations[Math.floor(Math.random() * clinic1Locations.length)]?.id ??
              clinic1Locations[0]?.id ??
              clinic1.id)
            : clinic1.id, // Fallback to clinic ID if no locations
        startTime: faker.date.future(),
        endTime: faker.date.future(),
      },
      // Connect doctor to Vishwamurti clinic with a random location
      {
        doctorId: doctor.id,
        clinicId: clinic2.id,
        locationId:
          clinic2Locations.length > 0
            ? (clinic2Locations[Math.floor(Math.random() * clinic2Locations.length)]?.id ??
              clinic2Locations[0]?.id ??
              clinic2.id)
            : clinic2.id, // Fallback to clinic ID if no locations
        startTime: faker.date.future(),
        endTime: faker.date.future(),
      },
    ]);

    // Create doctor-clinic relationships in batches to handle duplicates
    for (const data of doctorClinicData) {
      try {
        (await (prisma.doctorClinic.create({
          data,
        }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
      } catch (error) {
        // Skip if relationship already exists
        const prismaError = error as { code?: string };
        if (prismaError.code !== 'P2002') {
          throw error;
        }
      }
    }

    // Create Receptionists with clinic associations
    console.log('Creating receptionists...');
    const receptionistUsers = users.filter(
      (u): u is { id: string; role: string } => u.role === RoleValues.RECEPTIONIST
    );

    // First create receptionists with clinic and location association
    const receptionists = (await Promise.all(
      receptionistUsers.map((user, index) => {
        const clinicId = index % 2 === 0 ? clinic1.id : clinic2.id;
        const _locations = index % 2 === 0 ? clinic1Locations : clinic2Locations;
        const _locationId =
          _locations.length > 0
            ? (_locations[Math.floor(Math.random() * _locations.length)]?.id ??
              _locations[0]?.id ??
              null)
            : null;
        return prisma.receptionist.create({
          data: {
            userId: user.id,
            clinicId: clinicId,
          },
        }) as unknown as Promise<{ id: string }>;
      })
    )) as unknown as Array<{ id: string }>;

    // Then create the many-to-many relationships
    console.log('Creating receptionist-clinic relationships...');
    await Promise.all(
      receptionists.map((receptionist, index) => {
        const clinicId = index % 2 === 0 ? clinic1.id : clinic2.id;
        return prisma.receptionistsAtClinic.create({
          data: {
            A: clinicId, // clinic id
            B: receptionist.id, // receptionist id
          },
        }) as unknown as Promise<{ id: string }>;
      })
    );

    // Create Patients with clinic associations
    console.log('Creating patients...');
    const patientUsers = users.filter(
      (u): u is { id: string; role: string } => u.role === RoleValues.PATIENT
    );
    const patients = (await Promise.all(
      patientUsers.map(
        user =>
          prisma.patient.create({
            data: {
              prakriti: faker.helpers.arrayElement(Object.values(Prakriti)),
              dosha: faker.helpers.arrayElement(Object.values(Dosha)),
              user: {
                connect: {
                  id: user.id,
                },
              },
            },
          }) as unknown as Promise<{ id: string; userId: string }>
      )
    )) as unknown as Array<{ id: string; userId: string }>;

    // After creating patients, connect them to clinics
    await Promise.all(
      patients.flatMap(patient => [
        prisma.user.update({
          where: { id: patient.userId },
          data: {
            clinics: {
              connect: { id: clinic1.id },
            },
          },
        }) as unknown as Promise<{ id: string }>,
        prisma.user.update({
          where: { id: patient.userId },
          data: {
            clinics: {
              connect: { id: clinic2.id },
            },
          },
        }) as unknown as Promise<{ id: string }>,
      ])
    );

    // ===== DOCTOR DEMO USER =====
    const demoDoctor = (await (prisma.user.create({
      data: {
        email: 'doctor1@example.com',
        password: await bcrypt.hash('test1234', 12), // Use 12 rounds to match AuthService
        name: 'Demo Doctor',
        age: 45,
        firstName: 'Demo',
        lastName: 'Doctor',
        phone: '9000000002',
        role: RoleValues.DOCTOR,
        gender: Gender.FEMALE,
        isVerified: true,
        userid: generateUserId(),
        clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
        primaryClinicId: clinic2.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    const _demoDoctorRecord = (await (prisma.doctor.create({
      data: {
        id: demoDoctor.id,
        userId: demoDoctor.id,
        specialization: 'General Medicine',
        experience: 10,
        qualification: 'MBBS',
        rating: 4.5,
        isAvailable: true,
        consultationFee: 1000,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    (await (prisma.doctorClinic.create({
      data: {
        doctorId: demoDoctor.id,
        clinicId: clinic1.id,
        locationId: clinic1Locations[0]?.id ?? clinic1.id,
        startTime: new Date(),
        endTime: new Date(),
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    (await (prisma.doctorClinic.create({
      data: {
        doctorId: demoDoctor.id,
        clinicId: clinic2.id,
        locationId: clinic2Locations[0]?.id ?? clinic2.id,
        startTime: new Date(),
        endTime: new Date(),
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // ===== PATIENT DEMO USER =====
    const demoPatient = (await (prisma.user.create({
      data: {
        email: 'patient1@example.com',
        password: await bcrypt.hash('test1234', 12), // Use 12 rounds to match AuthService
        name: 'Demo Patient',
        age: 30,
        firstName: 'Demo',
        lastName: 'Patient',
        phone: '9000000003',
        role: RoleValues.PATIENT,
        gender: Gender.OTHER,
        isVerified: true,
        userid: generateUserId(),
        clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
        primaryClinicId: clinic1.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    const _demoPatientRecord = (await (prisma.patient.create({
      data: {
        prakriti: Prakriti.VATA,
        dosha: Dosha.PITTA,
        user: { connect: { id: demoPatient.id } },
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // ===== RECEPTIONIST DEMO USER =====
    const demoReceptionist = (await (prisma.user.create({
      data: {
        email: 'receptionist1@example.com',
        password: await bcrypt.hash('test1234', 12), // Use 12 rounds to match AuthService
        name: 'Demo Receptionist',
        age: 28,
        firstName: 'Demo',
        lastName: 'Receptionist',
        phone: '9000000004',
        role: RoleValues.RECEPTIONIST,
        gender: Gender.FEMALE,
        isVerified: true,
        userid: generateUserId(),
        clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
        primaryClinicId: clinic2.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    const _demoReceptionistRecord = (await (prisma.receptionist.create({
      data: {
        userId: demoReceptionist.id,
        clinicId: clinic2.id,
      },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    (await (prisma.receptionistsAtClinic.create({
      data: { A: clinic1.id, B: _demoReceptionistRecord.id },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };
    (await (prisma.receptionistsAtClinic.create({
      data: { A: clinic2.id, B: _demoReceptionistRecord.id },
    }) as unknown as Promise<{ id: string }>)) as unknown as { id: string };

    // Create additional staff roles with location associations
    console.log('Creating additional staff roles (Pharmacist, Therapist, LabTechnician, etc.)...');

    // Helper function to create staff users and their role records
    const createStaffRoleUsers = async (
      roleName: string,
      roleValue: string,
      count: number = Math.floor(SEED_COUNT / 4) // Create fewer of each additional role
    ) => {
      const staffUsers = (await Promise.all(
        Array(count)
          .fill(null)
          .map(
            async (_, i) =>
              prisma.user.create({
                data: {
                  email: faker.internet.email(),
                  password: await bcrypt.hash('test1234', 12),
                  name: faker.person.fullName(),
                  age: faker.number.int({ min: 25, max: 60 }),
                  firstName: faker.person.firstName(),
                  lastName: faker.person.lastName(),
                  phone: faker.phone.number(),
                  role: roleValue as Role,
                  gender: faker.helpers.arrayElement(Object.values(Gender)),
                  isVerified: true,
                  userid: generateUserId(),
                  clinics: { connect: [{ id: clinic1.id }, { id: clinic2.id }] },
                  primaryClinicId: i % 2 === 0 ? clinic1.id : clinic2.id,
                },
              }) as unknown as Promise<{ id: string; role: string }>
          )
      )) as unknown as Array<{ id: string; role: string }>;

      // Create role-specific records with location associations
      await Promise.all(
        staffUsers.map((user, index) => {
          const _clinicId = index % 2 === 0 ? clinic1.id : clinic2.id;
          const _locations = index % 2 === 0 ? clinic1Locations : clinic2Locations;
          const _locationId =
            _locations.length > 0
              ? (_locations[Math.floor(Math.random() * _locations.length)]?.id ??
                _locations[0]?.id ??
                null)
              : null;

          switch (roleValue) {
            case RoleValues.PHARMACIST:
              return prisma.pharmacist.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.THERAPIST:
              return prisma.therapist.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.LAB_TECHNICIAN:
              return prisma.labTechnician.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.FINANCE_BILLING:
              return prisma.financeBilling.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.SUPPORT_STAFF:
              return prisma.supportStaff.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.NURSE:
              return prisma.nurse.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            case RoleValues.COUNSELOR:
              return prisma.counselor.create({
                data: {
                  userId: user.id,
                },
              }) as unknown as Promise<{ id: string }>;
            default:
              return Promise.resolve({ id: '' });
          }
        })
      );
    };

    // Create staff roles
    await createStaffRoleUsers('Pharmacist', RoleValues.PHARMACIST, 5);
    await createStaffRoleUsers('Therapist', RoleValues.THERAPIST, 5);
    await createStaffRoleUsers('LabTechnician', RoleValues.LAB_TECHNICIAN, 5);
    await createStaffRoleUsers('FinanceBilling', RoleValues.FINANCE_BILLING, 3);
    await createStaffRoleUsers('SupportStaff', RoleValues.SUPPORT_STAFF, 5);
    await createStaffRoleUsers('Nurse', RoleValues.NURSE, 5);
    await createStaffRoleUsers('Counselor', RoleValues.COUNSELOR, 3);

    // Create LocationHead users (one per location)
    console.log('Creating LocationHead users...');
    const locationHeadUsers = await Promise.all(
      [...clinic1Locations, ...clinic2Locations].map(async (location, index) => {
        const clinicId: string = index < clinic1Locations.length ? clinic1.id : clinic2.id;
        const user = await prisma.user.create({
          data: {
            email: `locationhead-${location.id.substring(0, 8)}@example.com`,
            password: await bcrypt.hash('test1234', 12),
            name: `Location Head ${index + 1}`,
            age: faker.number.int({ min: 30, max: 50 }),
            firstName: 'Location',
            lastName: `Head ${index + 1}`,
            phone: faker.phone.number(),
            role: 'CLINIC_ADMIN' as Role, // Using CLINIC_ADMIN temporarily until LOCATION_HEAD is added to Role enum
            gender: faker.helpers.arrayElement(Object.values(Gender)),
            isVerified: true,
            userid: generateUserId(),
            clinics: { connect: { id: clinicId } },
            primaryClinicId: clinicId,
          },
        });
        return { user: { id: user.id }, location, clinicId };
      })
    );

    // Create LocationHead records
    await Promise.all(
      locationHeadUsers.map(async ({ user, location, clinicId }) => {
        // Create LocationHead record using Prisma client
        await (
          prisma as unknown as {
            locationHead: {
              create: (args: {
                data: {
                  userId: string;
                  clinicId: string;
                  locationId: string;
                  assignedBy: string;
                  isActive: boolean;
                };
              }) => Promise<{ id: string }>;
            };
          }
        ).locationHead.create({
          data: {
            userId: user.id,
            clinicId: clinicId,
            locationId: location.id,
            assignedBy: superAdminUser.id,
            isActive: true,
          },
        });
      })
    );

    // Assign RBAC roles to LocationHead users
    await Promise.all(
      locationHeadUsers.map(
        ({ user, clinicId }) => assignRoleToUser(user.id, RoleValues.CLINIC_ADMIN, clinicId) // Using CLINIC_ADMIN temporarily until LOCATION_HEAD is added to Role enum
      )
    );
    console.log(`✓ Created ${locationHeadUsers.length} LocationHead users`);

    // Create sample data only in development environment
    // Use helper functions (which use dotenv) for environment variable access
    if (isDevelopment()) {
      // Create Medicines
      console.log('Creating medicines...');
      const medicines1 = (await Promise.all(
        Array(SEED_COUNT)
          .fill(null)
          .map(
            () =>
              prisma.medicine.create({
                data: {
                  name: faker.commerce.productName(),
                  ingredients: faker.commerce.productMaterial(),
                  properties: faker.commerce.productDescription(),
                  dosage: faker.number.int({ min: 1, max: 3 }) + ' times daily',
                  manufacturer: faker.company.name(),
                  type: faker.helpers.arrayElement(Object.values(MedicineType)),
                  clinicId: clinic1.id,
                },
              }) as unknown as Promise<{ id: string }>
          )
      )) as unknown as Array<{ id: string }>;

      const medicines2 = (await Promise.all(
        Array(SEED_COUNT)
          .fill(null)
          .map(
            () =>
              prisma.medicine.create({
                data: {
                  name: faker.commerce.productName(),
                  ingredients: faker.commerce.productMaterial(),
                  properties: faker.commerce.productDescription(),
                  dosage: faker.number.int({ min: 1, max: 3 }) + ' times daily',
                  manufacturer: faker.company.name(),
                  type: faker.helpers.arrayElement(Object.values(MedicineType)),
                  clinicId: clinic2.id,
                },
              }) as unknown as Promise<{ id: string }>
          )
      )) as unknown as Array<{ id: string }>;

      const _medicines = [...medicines1, ...medicines2];

      // Create Therapies
      console.log('Creating therapies...');
      await Promise.all([
        ...Array(SEED_COUNT)
          .fill(null)
          .map(
            () =>
              prisma.therapy.create({
                data: {
                  name: faker.commerce.productName(),
                  description: faker.commerce.productDescription(),
                  duration: faker.number.int({ min: 30, max: 120 }),
                  clinicId: clinic1.id,
                },
              }) as unknown as Promise<{ id: string }>
          ),
        ...Array(SEED_COUNT)
          .fill(null)
          .map(
            () =>
              prisma.therapy.create({
                data: {
                  name: faker.commerce.productName(),
                  description: faker.commerce.productDescription(),
                  duration: faker.number.int({ min: 30, max: 120 }),
                  clinicId: clinic2.id,
                },
              }) as unknown as Promise<{ id: string }>
          ),
      ]);

      // Create sample appointments and related data
      console.log('Creating sample appointments and related data...');

      // Helper function to generate realistic appointment times (business hours: 9 AM - 6 PM)
      const generateAppointmentDateTime = (daysFromNow: number) => {
        const date = new Date();
        date.setDate(date.getDate() + daysFromNow);

        // Random hour between 9 AM and 5 PM (to leave room for duration)
        const hour = faker.number.int({ min: 9, max: 17 });
        // Random minute: 0, 15, 30, or 45
        const minute = faker.helpers.arrayElement([0, 15, 30, 45]);

        date.setHours(hour, minute, 0, 0);
        return date;
      };

      const appointments = (await Promise.all(
        Array.from({ length: 30 }).map(async (_unused, index) => {
          // Create appointments spread over next 30 days
          const daysFromNow = Math.floor(index / 2) + 1; // 2 appointments per day
          const appointmentDateTime = generateAppointmentDateTime(daysFromNow);

          const timeString = appointmentDateTime.toLocaleTimeString('en-US', {
            hour12: false,
            hour: '2-digit',
            minute: '2-digit',
          });

          const doctor = doctors[index % doctors.length];
          const patient = patients[index % patients.length];

          if (!doctor || !patient) {
            throw new Error('Doctor or patient not found');
          }

          const isFirstClinic = index % 2 === 0;
          const clinicId = isFirstClinic ? clinic1.id : clinic2.id;
          const clinicLocations = isFirstClinic ? clinic1Locations : clinic2Locations;
          const locationId =
            clinicLocations.length > 0
              ? (clinicLocations[Math.floor(Math.random() * clinicLocations.length)]?.id ??
                clinicLocations[0]?.id ??
                clinicId)
              : clinicId;

          // Vary appointment types and statuses for realistic data
          const appointmentType = faker.helpers.arrayElement([
            AppointmentType.IN_PERSON,
            AppointmentType.VIDEO_CALL,
            AppointmentType.IN_PERSON,
          ]);

          // Most appointments should be scheduled/confirmed, some pending, few completed
          const status = faker.helpers.weightedArrayElement([
            { weight: 5, value: AppointmentStatus.SCHEDULED },
            { weight: 3, value: AppointmentStatus.CONFIRMED },
            { weight: 1, value: AppointmentStatus.PENDING },
            { weight: 1, value: AppointmentStatus.COMPLETED },
          ]);

          return prisma.appointment.create({
            data: {
              doctorId: doctor.id,
              patientId: patient.id,
              locationId: locationId,
              clinicId: clinicId,
              date: appointmentDateTime,
              time: timeString,
              duration: faker.helpers.arrayElement([15, 30, 45, 60]),
              type: appointmentType,
              status: status,
              notes: faker.lorem.sentence(),
              userId: patient.userId,
            },
          }) as unknown as Promise<{ id: string; clinicId: string; userId: string }>;
        })
      )) as unknown as Array<{ id: string; clinicId: string; userId: string }>;

      // Create specific appointments for demo users for easy testing
      console.log('Creating demo user appointments...');
      const demoAppointments = (await Promise.all([
        // Tomorrow at 10 AM
        prisma.appointment.create({
          data: {
            doctorId: demoDoctor.id,
            patientId: _demoPatientRecord.id,
            locationId: clinic1Locations[0]?.id ?? clinic1.id,
            clinicId: clinic1.id,
            date: (() => {
              const tomorrow = new Date();
              tomorrow.setDate(tomorrow.getDate() + 1);
              tomorrow.setHours(10, 0, 0, 0);
              return tomorrow;
            })(),
            time: '10:00',
            duration: 30,
            type: AppointmentType.IN_PERSON,
            status: AppointmentStatus.SCHEDULED,
            notes: 'Demo appointment for testing',
            userId: demoPatient.id,
          },
        }) as unknown as Promise<{ id: string }>,
        // Day after tomorrow at 2 PM
        prisma.appointment.create({
          data: {
            doctorId: demoDoctor.id,
            patientId: _demoPatientRecord.id,
            locationId: clinic1Locations[0]?.id ?? clinic1.id,
            clinicId: clinic1.id,
            date: (() => {
              const dayAfter = new Date();
              dayAfter.setDate(dayAfter.getDate() + 2);
              dayAfter.setHours(14, 0, 0, 0);
              return dayAfter;
            })(),
            time: '14:00',
            duration: 45,
            type: AppointmentType.VIDEO_CALL,
            status: AppointmentStatus.CONFIRMED,
            notes: 'Video consultation appointment for testing',
            userId: demoPatient.id,
          },
        }) as unknown as Promise<{ id: string }>,
      ])) as unknown as Array<{ id: string }>;

      console.log(
        `Created ${appointments.length} sample appointments + ${demoAppointments.length} demo appointments`
      );

      // Create CheckInLocations with locationId linking to ClinicLocation
      console.log('Creating check-in locations...');
      // Use unknown first for type assertion to avoid strict type checking issues
      const checkInLocationClient = prisma.checkInLocation as unknown as {
        create: (args: {
          data: {
            clinicId: string;
            locationId: string;
            locationName: string;
            qrCode: string;
            coordinates: { lat: number; lng: number };
            radius: number;
            isActive: boolean;
          };
        }) => Promise<{ id: string }>;
      };
      const checkInLocationsResults: Promise<Array<{ id: string }>> = Promise.all(
        [...clinic1Locations, ...clinic2Locations].map(
          async (clinicLocation, index): Promise<{ id: string }> => {
            const clinicId: string = index < clinic1Locations.length ? clinic1.id : clinic2.id;
            const locationIdStr = clinicLocation.id;
            const qrCode = `CHK-${clinicId.substring(0, 8)}-${locationIdStr.substring(0, 8)}-${Date.now()}-${Math.random().toString(36).substring(2, 15)}`;
            const created = await checkInLocationClient.create({
              data: {
                clinicId: clinicId,
                locationId: locationIdStr, // Link to ClinicLocation
                locationName: `Location Check-In ${index + 1}`,
                qrCode: qrCode,
                coordinates: {
                  lat: faker.location.latitude(),
                  lng: faker.location.longitude(),
                },
                radius: 100, // 100 meters radius
                isActive: true,
              },
            });
            return created;
          }
        )
      );
      checkInLocations = await checkInLocationsResults;
      console.log(
        `✓ Created ${checkInLocations.length} check-in locations with ClinicLocation linking`
      );

      // Create sample payments, queues, prescriptions, etc.
      await Promise.all([
        // Payments
        ...appointments.map(
          appointment =>
            prisma.payment.create({
              data: {
                amount: faker.number.float({ min: 500, max: 5000 }),
                status: faker.helpers.arrayElement(Object.values(PaymentStatus)),
                method: faker.helpers.arrayElement(Object.values(PaymentMethod)),
                transactionId: faker.string.uuid(),
                clinicId: appointment.clinicId,
                appointmentId: appointment.id,
              },
            }) as unknown as Promise<{ id: string; clinicId: string }>
        ),
        // Queues (with locationId from appointment)
        ...appointments.map((appointment, index) => {
          // Get locationId from appointment (commented out until clinicLocationId is added to Queue model)
          // const _appointmentWithLocation = appointment as { locationId?: string };
          return prisma.queue.create({
            data: {
              queueNumber: index + 1,
              estimatedWaitTime: faker.number.int({ min: 5, max: 60 }),
              status: faker.helpers.arrayElement(Object.values(QueueStatus)),
              clinicId: appointment.clinicId,
              appointmentId: appointment.id,
              // clinicLocationId will be added in future migration
              // clinicLocationId: appointmentWithLocation.locationId || null,
            },
          }) as unknown as Promise<{ id: string; clinicId: string }>;
        }),
      ]);
    }

    console.log('\n========================================');
    console.log('  Seeding Complete!');
    console.log('========================================\n');

    console.log('📋 Default Credentials:');
    console.log('  SuperAdmin: admin@example.com / admin123');
    console.log('  Clinic Admin: clinicadmin@example.com / admin123\n');

    console.log('🏥 Created Clinics:');
    console.log('  1. Aadesh Ayurvedalay (Clinic ID: CL0002, UUID: ' + clinic1.id + ')');
    console.log(
      '  2. Shri Vishwamurti Ayurvedalay (Clinic ID: CL0003, UUID: ' + clinic2.id + ')\n'
    );

    console.log('👥 Demo Login Credentials:');
    console.log('  Clinic Admin: clinicadmin1@example.com / test1234');
    console.log('  Doctor:       doctor1@example.com / test1234 (ID: ' + demoDoctor.id + ')');
    console.log('  Patient:      patient1@example.com / test1234 (ID: ' + demoPatient.id + ')');
    console.log('  Receptionist: receptionist1@example.com / test1234');
    if (locationHeadUsers.length > 0) {
      console.log(
        `  LocationHead: ${locationHeadUsers[0]?.user ? 'locationhead-*@example.com' : 'N/A'} / test1234`
      );
    }
    console.log('');

    // Export test IDs for automated testing
    const testIds = {
      clinics: [clinic1.id, clinic2.id],
      clinicNames: ['Aadesh Ayurvedalay', 'Shri Vishwamurti Ayurvedalay'],
      demoDoctorId: demoDoctor.id,
      demoPatientId: demoPatient.id,
      demoReceptionistId: demoReceptionist.id,
      demoClinicAdminId: demoClinicAdmin.id,
      superAdminId: superAdminUser.id,
      doctors: doctors.slice(0, 5).map(d => d.id),
      patients: patients.slice(0, 5).map(p => p.id),
      locations: {
        clinic1: clinic1Locations.map(l => l.id),
        clinic2: clinic2Locations.map(l => l.id),
      },
      locationHeads: locationHeadUsers.slice(0, 3).map(lh => lh.user.id),
      checkInLocations: ((): string[] => {
        const locations = checkInLocations as Array<{ id: string }>;
        return locations.length > 0 ? locations.slice(0, 3).map(cil => cil.id) : [];
      })(),
    };

    exportTestIds(testIds);
  } catch (error) {
    console.error('Error during seeding:', error);
    throw error;
  } finally {
    await (prisma.$disconnect() as unknown as Promise<void>);
  }
}

// Function to wait for database to be ready
async function waitForDatabase() {
  console.log('Waiting for database connection...');
  let retries = 5;
  while (retries > 0) {
    try {
      // Try a simple query to verify database is ready
      await prisma.clinic.findFirst({ take: 1 });
      console.log('Database connection established.');
      return;
    } catch (error) {
      console.log(`Database not ready yet, retrying... (${retries} attempts left)`);
      if (error instanceof Error) {
        console.log(`Error: ${error.message}`);
      }
      retries -= 1;
      await new Promise(resolve => setTimeout(resolve, 2000));
    }
  }
  throw new Error('Failed to connect to database after multiple attempts');
}

// Function to clean up database
async function cleanDatabase() {
  try {
    // Delete records in reverse order of dependencies
    const tables = [
      'auditLog',
      'notification',
      'prescriptionItem',
      'prescription',
      'review',
      'healthRecord',
      'checkIn',
      'checkInLocation',
      'queue',
      'payment',
      'appointment',
      'product',
      'medicine',
      'therapy',
      'doctorClinic',
      'doctor',
      'receptionist',
      'patient',
      'pharmacist',
      'therapist',
      'labTechnician',
      'financeBilling',
      'supportStaff',
      'nurse',
      'counselor',
      'locationHead',
      'clinicAdmin',
      'clinicLocation',
      'receptionistsAtClinic',
      'userRole', // Add UserRole to cleanup
      'clinic',
      'superAdmin',
      'user',
    ];

    for (const table of tables) {
      try {
        // Type-safe access to Prisma delegates
        type PrismaDelegate = {
          deleteMany: (args?: Record<string, never>) => Promise<{ count: number }>;
        };
        const delegate = (prisma as unknown as Record<string, PrismaDelegate>)[table];
        if (delegate) {
          await delegate.deleteMany({});
          console.log(`Cleaned ${table} table`);
        }
      } catch (error) {
        // Skip if table doesn't exist
        console.log(`Skipping ${table} table (may not exist yet)`);
        if (error instanceof Error) {
          console.log(`Error: ${error.message}`);
        }
      }
    }
  } catch (error) {
    console.error('Error cleaning database:', error);
    throw error;
  }
}

console.log('Starting seed script main function...');
main()
  .then(() => {
    console.log('Seed script completed successfully!');
  })
  .catch(e => {
    console.error('Seed script failed:', e);
    console.error('Error stack:', e instanceof Error ? e.stack : String(e));
    process.exit(1);
  })
  .finally(async () => {
    console.log('Disconnecting from database...');
    try {
      await prisma.$disconnect();
    } catch (error) {
      console.error('Error disconnecting Prisma:', error);
    }
    try {
      if (pool) {
        await pool.end();
      }
    } catch (error) {
      console.error('Error closing pool:', error);
    }
    console.log('Disconnected');
  });
